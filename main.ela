#c_flags " -lasound "
import fmt::*;
import midi::*;
import math;
import pthread::*;
import jst::{
  Instrument,
  Signal
};
import fs::Directory;
import sineboard::*;

extern fn snd_pcm_open(handle: *mut *mut void, name: *const u8, stream: s32, mode: s32) -> s32;
extern fn snd_pcm_set_params(handle: *mut void, format: s32, access: s32, channels: u32, rate: u32, soft_resample: s32, latency: u32) -> s32;
extern fn snd_pcm_writei(handle: *mut void, buffer: *const void, size: s32) -> s32;
extern fn snd_pcm_close(handle: *mut void) -> s32;
extern fn snd_pcm_prepare(handle: *mut void) -> s32;

const SND_PCM_STREAM_PLAYBACK: s32 = 0;
const SND_PCM_FORMAT_FLOAT_LE: s32 = 14;
const SND_PCM_ACCESS_RW_INTERLEAVED: s32 = 3;

const BLOCK_SIZE: s32 = 256;
const OUTPUT_GAIN: f32 = 0.2;

struct SignalQueue {
  queue: List!<Signal>,
  mutex: pthread::Mutex = pthread::Mutex::new(),
}

impl Destroy for SignalQueue {
  fn destroy(*mut self, recursive: bool = true) {
    self.queue.destroy(recursive);
    self.mutex.destroy();
  }
}

impl SignalQueue {
  fn push(*mut self, signal: Signal) {
    self.mutex.lock();
    self.queue.push(signal);
    self.mutex.unlock();
  }
  fn pop(*mut self) -> Option!<Signal> {
    self.mutex.lock();
    signal := if self.queue.length > 0 {
      return Some(self.queue.pop_front());
    } else {
      return None();
    };
    self.mutex.unlock();
    return signal;
  }
}

struct Context {
  instruments: List!<dyn Instrument>,
  pcm: *mut void,
  sample_rate: u32,
}

impl Context {
  fn init_pcm(*mut self, sample_rate: u32) -> bool {
    if snd_pcm_open(&mut self.pcm, "default"c, SND_PCM_STREAM_PLAYBACK, 0) != 0 {
      fmt::println("Failed to open ALSA device");
      return false;
    }
    self.sample_rate = sample_rate;
    snd_pcm_set_params(self.pcm, SND_PCM_FORMAT_FLOAT_LE, SND_PCM_ACCESS_RW_INTERLEAVED, 1, sample_rate, 1, 30_000);
    return true;
  }
}

impl Destroy for Context {
  fn destroy(*mut self, recursive: bool = true) {
    self.instruments.destroy(recursive);
    if self.pcm != null {
      snd_pcm_close(self.pcm);
      self.pcm = null;
    }
  }
}

fn assemble_master_mix(context: *mut Context, out: *mut f32, n: s32) {
  for instrument in context.instruments.iter_mut() {
    instrument.mix_voices(out, n, context.sample_rate);
  }
  // run FX here.
  for i in 0..n {
    out![i] = math::clamp!<f32>(out![i], -1, 1);
  }
  for i in 0..n {
    out![i] *= OUTPUT_GAIN;
  }
}

fn audio_thread_main(arg: *mut void) {
  context: *mut Context = arg;
  while true {
    mut buffer: [f32; BLOCK_SIZE];
    assemble_master_mix(context, buffer, BLOCK_SIZE);
    mut written: s32;
    if (written = snd_pcm_writei(context.pcm, buffer, BLOCK_SIZE)) < 0 {
      snd_pcm_prepare(context.pcm); 
      fmt::printlnf("ALSA write error: %", (written,), FormatOptions.{});
    }
  }
}

fn on_midi_event(status: s32, note: s32, velocity: s32, user_arg: *mut void) -> bool {
  context: *mut Context = user_arg;
  for instrument in context.instruments.iter_mut() {
    instrument.handle_midi_event(status, note, velocity, context.sample_rate);
  }
  return true;
}

fn on_init(user_arg: *mut void) -> bool {
  context: *mut Context = user_arg;
  for instrument in context.instruments {
    if !instrument.initialize() {
      fmt::println("failed to initialize instrument");
    }
  }
  return true;
}

fn main() {
  using mut ctx: Context;
  if !ctx.init_pcm(44100) {
    return;
  }
  mut sine_board: SineBoard;
  ctx.instruments.push(dynof(&mut sine_board, Instrument));
  mut dir := if Directory::open("/dev/snd") is Option!<Directory>::Some(dir) {
    return dir;
  } else {
    panic("Unable to open /dev/snd");
  };


  mut i := 1;
  mut midi_devices: List!<String>;
  for entry in dir.entries {
    if entry.starts_with("midi") {
      midi_devices.push(entry);
      printlnf("(%) %", (i, entry));
    }
  }

  if midi_devices.length == 0 {
    println("No midi devices found");
    return;
  }

  mut selection: s32 = 1;
  if midi_devices.length > 1 {
    println("Select midi device and press enter");
    while true {
      if std::c::scanf("%d"c, &selection) != 1 || selection > midi_devices.length || selection <= 0 {
        println("Selection invalid, try again");
      } else {
        break;
      }
    }
  } else {
    println("Auto selected the only device available");
  }

  using midi_device_file := fmt::format("/dev/snd/%", (midi_devices[selection - 1],), FormatOptions.{});
  mut audio_thread := Thread::start(&mut audio_thread_main, &mut ctx);
  midi::begin_midi_hook(midi_device_file.as_str(), &mut on_init, &mut on_midi_event, &mut ctx);
}
