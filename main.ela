#c_flags " -lasound "
import fmt::*;
import midi::*;
import math;
import pthread::*;
import jst::{
  Instrument,
  Signal
};

extern fn snd_pcm_open(handle: *mut *mut void, name: *const u8, stream: s32, mode: s32) -> s32;
extern fn snd_pcm_set_params(handle: *mut void, format: s32, access: s32, channels: u32, rate: u32, soft_resample: s32, latency: u32) -> s32;
extern fn snd_pcm_writei(handle: *mut void, buffer: *const void, size: s32) -> s32;
extern fn snd_pcm_close(handle: *mut void) -> s32;
extern fn snd_pcm_prepare(handle: *mut void) -> s32;

const SND_PCM_STREAM_PLAYBACK: s32 = 0;
const SND_PCM_FORMAT_FLOAT_LE: s32 = 14;
const SND_PCM_ACCESS_RW_INTERLEAVED: s32 = 3;

const BLOCK_SIZE: s32 = 256;
const OUTPUT_GAIN: f32 = 0.2;

struct SignalQueue {
  queue: List!<Signal>,
  mutex: pthread::Mutex = pthread::Mutex::new(),
}

impl Destroy for SignalQueue {
  fn destroy(*mut self, recursive: bool = true) {
    self.queue.destroy(recursive);
    self.mutex.destroy();
  }
}

impl SignalQueue {
  fn push(*mut self, signal: Signal) {
    self.mutex.lock();
    self.queue.push(signal);
    self.mutex.unlock();
  }
  fn pop(*mut self) -> Option!<Signal> {
    self.mutex.lock();
    signal := if self.queue.length > 0 {
      return Some(self.queue.pop_front());
    } else {
      return None();
    };
    self.mutex.unlock();
    return signal;
  }
}

struct Context {
  instruments: List!<dyn Instrument>,
  pcm: *mut void,
  sample_rate: u32,
}

impl Context {
  fn init_pcm(*mut self, sample_rate: u32) -> bool {
    if snd_pcm_open(&mut self.pcm, "default"c, SND_PCM_STREAM_PLAYBACK, 0) != 0 {
      fmt::println("Failed to open ALSA device");
      return false;
    }
    self.sample_rate = sample_rate;
    snd_pcm_set_params(self.pcm, SND_PCM_FORMAT_FLOAT_LE, SND_PCM_ACCESS_RW_INTERLEAVED, 1, sample_rate, 1, 30_000);
    return true;
  }
}

impl Destroy for Context {
  fn destroy(*mut self, recursive: bool = true) {
    self.instruments.destroy(recursive);
    if self.pcm != null {
      snd_pcm_close(self.pcm);
      self.pcm = null;
    }
  }
}
// Improved one-pole IIR lowpass filter for audio smoothing
fn lowpass_filter(out: *mut f32, n: s32, smoothing: f32) {
  mut prev: f32 = out![0];
  for i in 1..n {
    out![i] = prev + smoothing * (out![i] - prev);
    prev = out![i];
  }
}

fn mix_instruments(context: *mut Context, out: *mut f32, n: s32) {
  for instrument in context.instruments.iter_mut() {
    mut voices := instrument.get_active_voices();
    instrument.mix_voices(out, n, context.sample_rate);
    instrument.apply_envelope(context.sample_rate);
  }


  for i in 0..n {
    out![i] *= OUTPUT_GAIN;
  }
  for i in 0..n {
    out![i] = math::clamp!<f32>(out![i], -1, 1);
  }
}

fn audio_thread_main(arg: *mut void) {
  context: *mut Context = arg;
  mut buffer: [f32; BLOCK_SIZE];
  while true {
    std::c::memset(buffer, 0, BLOCK_SIZE * sizeof(f32));
    mix_instruments(context, buffer, BLOCK_SIZE);
    mut written: s32;
    if (written = snd_pcm_writei(context.pcm, buffer, BLOCK_SIZE)) < 0 {
      snd_pcm_prepare(context.pcm); 
      fmt::printlnf("ALSA write error: %", (written,), FormatOptions.{});
    }
  }
}

fn sine_generator(type_erased_voice: *mut void) -> f32 {
  voice: *mut Voice = type_erased_voice;

  {
    voice.phase += voice.phase_inc;
    if voice.phase > 2.0 * 3.14159265 {
      voice.phase -= 2.0 * 3.14159265;
    }
  }

  phase := voice.phase;
  sample := voice.velocity * math::cos(phase) as f32;
  return sample;
}

const MIN_VALUE := 0.02;

struct SineBoard {
  voices: List!<Voice>,
  attack:  f32 = MIN_VALUE,
  decay:   f32 = 1,
  sustain: f32 = 1,
  release: f32 = 0,
}

impl Instrument for SineBoard {
  fn initialize(*mut self) -> bool {
    return true;
  }
  fn handle_midi_event(*mut self, status: s32, note: s32, velocity: s32, sample_rate: f32) {
    if status == 0x90 && velocity > 0 {
      freq: f32 = pitch_from_midi_note_id(note);
      self.voices.push(Voice.{
        freq: freq,
        velocity: velocity as f32 / 127.0,
        phase_inc: 2.0 * 3.14159265 * freq / sample_rate,
        released: false,
        generator: &mut sine_generator,
      });
    } else if (status == 0x80) || (status == 0x90 && velocity == 0) {
      freq: f32 = pitch_from_midi_note_id(note);
      for voice in self.voices.iter_mut() {
        if math::abs(voice.freq - freq) < 1.0 {
          voice.env_state = 3;
        }
      }
    }
  }
  fn mix_voices(*mut self, out: *mut f32, n: s32, sample_rate: u32) {
    self.apply_envelope(sample_rate);
    for i in 0..n {
      for voice in self.voices.iter_mut() {
        if voice.env_state != 4 {
          out![i] += voice.generator(voice);
        }
      }
    }
    self.voices.retain(fn (voice: *Voice) -> bool {
      return voice.env_state != 4;
    });
  }
  fn apply_envelope(*mut self, sample_rate: u32) {
    for voice in self.voices.iter_mut() {
      if voice.env_state == 0 {
        voice.envelope += 1.0 / (self.attack * sample_rate as f32);
        if voice.envelope >= 1.0 {
          voice.envelope = 1.0;
          voice.env_state = 1;
        }
      } else if voice.env_state == 1 {
        voice.envelope -= (1.0 - self.sustain) / (self.decay * sample_rate as f32);
        if voice.envelope <= self.sustain {
          voice.envelope = self.sustain;
          voice.env_state = 2;
        }
      } else if voice.env_state == 3 {
        voice.envelope -= self.sustain / (self.release * sample_rate as f32);
        if voice.envelope <= 0.0 {
          voice.envelope = 0.0;
          voice.env_state = 4;
        }
      }
    }
  }
  fn get_active_voices(*mut self) -> mut [Voice] {
    return self.voices.as_slice_mut();
  }
}

fn on_midi_event(status: s32, note: s32, velocity: s32, user_arg: *mut void) -> bool {
  context: *mut Context = user_arg;
  for instrument in context.instruments.iter_mut() {
    instrument.handle_midi_event(status, note, velocity, context.sample_rate);
  }
  return true;
}

fn on_init(user_arg: *mut void) -> bool {
  context: *mut Context = user_arg;
  for instrument in context.instruments {
    if !instrument.initialize() {
      fmt::println("failed to initialize instrument");
    }
  }
  return true;
}

fn main() {
  using mut ctx: Context;
  if !ctx.init_pcm(44100) {
    return;
  }
  mut sine_board: SineBoard;
  ctx.instruments.push(dynof(&mut sine_board, Instrument));
  mut audio_thread := Thread::start(&mut audio_thread_main, &mut ctx);
  midi::begin_midi_hook("/dev/snd/midiC1D0", &mut on_init, &mut on_midi_event, &mut ctx);
}
