import jst::*;
import map::*;

struct SineBoard {
  voices: List!<Voice>,
  envelope: Envelope = .{
    attack: 0.001,
    release: 0.001,
  },
  parameters: InstrumentParameters,
}

// basic sine oscillator / sample generator.
fn sine_generator(voice: *mut Voice, parameters: *mut InstrumentParameters) -> f32 {
  voice.phase += voice.phase_step * parameters.pitch_bend;
  if voice.phase > 2.0 * 3.14159265 {
    voice.phase -= 2.0 * 3.14159265;
  }
  phase := voice.phase;
  return  voice.velocity * voice.envelope.value * math::cos(phase) as f32;
}


fn fm_generator(voice: *mut Voice, parameters: *mut InstrumentParameters) -> f32 {
  f := sine_generator(voice, parameters);
  m := sine_generator(voice, parameters);
  mod_index: f32 = f * math::atan2(f, m) - 1;
  carrier_phase := voice.phase + mod_index * m;
  mut sample := voice.velocity * voice.envelope.value * math::cos(carrier_phase) as f32;
  sample *= math::sin(carrier_phase);
  return sample;
}

impl Instrument for SineBoard {
  fn set_voice_parameters(*mut self, freq: f32, voice: *mut Voice) {
    voice.generator = &mut sine_generator;
    // voice.generator = fn(voice: *mut Voice, parameters: *mut InstrumentParameters) -> f32 {
    //   f := fm_generator(voice, parameters);
    //   m := fm_generator(voice, parameters) * math::asin(f * 2);
    //   mod_index: f32 = f * math::atan2(f, m) * 2;
    //   carrier_phase := voice.phase + mod_index * m;
    //   sample := voice.velocity * voice.envelope * math::cos(carrier_phase) as f32;
    //   return sample;
    // };
  }
}

struct Echo {
  buffer: List!<f32>,
  index: s32 = 0,
  delay_samples: s32 = 36000,
  depth: f32 = 0.7,
  repetitions: s32 = 4,
}

impl Effect for Echo {
  fn init(*mut self) {
    self.buffer.initialize(self.delay_samples * self.repetitions);
  }
  fn process(*mut self, mut data: mut [f32]) {
    for i in 0..data.length {
      mut out := data[i];
      for n in 1..self.repetitions + 1 {
        tap_delay := self.delay_samples * n;
        tap_idx := (self.index + self.buffer.length - tap_delay) % self.buffer.length;
        tap := self.buffer[tap_idx];
        out += tap * (self.depth / (n as f32));
      }
      self.buffer[self.index] = data[i];
      data[i] = out;
      self.index = (self.index + 1) % self.buffer.length;
    }
  }
}