module std {
  extern fn read(__fd: s32, __buf: *mut void, __nbytes: u64) -> s64;
  extern fn write(__fd: s32, __buf: *const void, __n: u64) -> s64;
  extern fn open(__file: *const u8, __oflag: s32, __mode: s32) -> s32;
  extern fn close(__fd: s32) -> s32;
}

type SampleGenerator :: fn(*mut void) -> f32;

struct Voice {
  freq: f32,
  velocity: f32,
  phase: f32,
  phase_inc: f32,
  envelope: f32,
  env_state: s32,
  release_start: f32,
  released: bool,
  generator: SampleGenerator,
}

impl Voice {
  fn new(freq: f32, velocity: f32, sample_rate: f32, generator: SampleGenerator) -> Self {
    return Voice.{
      freq: freq,
      velocity: velocity,
      phase: 0.0,
      phase_inc: 2.0 * 3.14159265 * freq / sample_rate,
      envelope: 0.0,
      env_state: 0,
      release_start: 0.0,
      released: false,
      generator: generator,
    };
  }
}

const O_RDWR:   s32 = 0x2;
const S_IRUSR: s32 = 0x100;
const S_IWUSR: s32 = 0x80;

const MIDI_NOTE_OFF := 0x80;
const MIDI_NOTE_ON := 0x90;

type MidiCallback :: fn(s32, s32, s32, *mut void) -> bool;

const note_names: [str; 12] = .[
  "C",
  "Db",
  "D",
  "Eb",
  "E",
  "F",
  "F#",
  "G",
  "Ab",
  "A",
  "Bb",
  "B",
];

// A4=440hz tuning of course.
fn pitch_from_midi_note_id(note_id: s32) -> f32 {
  return 440.0 * math::pow(2.0, (note_id as f32 - 69.0) / 12.0);
}

fn begin_midi_hook(mut device: str, init_callback: fn(*mut void) -> bool, midi_callback: MidiCallback, user_arg: *mut void) {
  mut fd := 0;
  if (fd = std::open(device.data, O_RDWR, S_IRUSR | S_IWUSR)) == -1 {
    std::printf("failed to open midi\n");
    return;
  }
  defer std::close(fd);

  if !init_callback(user_arg) {
    return;
  }

  const N_VOICES := 12;
  const N_BYTES := N_VOICES * 3;
  mut buf: [u8; N_BYTES];
  mut bytes_read := 0;
  while (bytes_read = std::read(fd, buf, N_BYTES)) != -1 {
    for idx in 0..(bytes_read/3) {
      if !midi_callback(buf[idx+0], buf[idx+1], buf[idx+2], user_arg) {
        return;
      }
    }
  }
}